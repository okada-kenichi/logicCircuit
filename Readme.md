# 論理回路シミュレーション
## これは何？
論理回路のシミュレーター。真と偽のふたつの値だけで計算を行う足し算専用マシーン。  
JavaScriptなのでブラウザのコンソールでも動く。
## できること
二進数同士の足し算ができる。ふたつの二進数を引数に渡すとその合計が返ってくる。戻り値も二進数。  
今回作った関数addition()の引数に、足し算したいふたつの二進数を渡すと合計が返ってくる。  
例: addition(101, 1011); -> 10000
## どのように計算しているか
  
- AND回路を定義
- OR回路を定義
- NOT回路を定義
- 上記三つをもとに半加算機を定義
- 上記四つをもとに全加算機を定義

実際に真偽のふたつの値だけで足し算を行っている。全加算機を好きなだけ繋げれば何桁でも足し算できる。
## プログラムについて詳しく
論理回路は真偽判定しかしないので、引数として渡す二進数はそれを考慮した形に整える必要がある。
加算する二進数は1と0で構成されるJavaScriptの配列で、一の位から計算するため配列の順を逆に並び替えておく必要がある。   
もちろんそれで十分シミュレーターとしては意味を成すのだが、毎回それをするのは使い勝手が悪いので論理回路とは別にもう少し使いやすくするコードを書いている。
  
## 入力する二進数について
桁数の異なるふたつの二進数を入力した場合、足りない桁はundefinedを渡す事になる。それでも論理回路が必ず0を返すのは入力が「1」かどうかだけをチェックしているから。1以外は必ず0を返すので問題なく機能している。  
  
とはいえundefinedをやりとりする前提なのもどうかと思うので、あらかじめゼロ埋めしたりして入力値を整形する仕組みをもう少しちゃんとしたほうがいいかもしれない。

## 俺か俺以外か
そこで気付いたこととして。  
扱うのはの1と0二値だけという前提なので「1か1以外か」をチェックしている。  
実装しているNOT回路を例にあげると、、  
```JavaScript:not
function not(a) {
    if (a === 1) {
        return 0;
    } else {
        return 1;
    }
}
```

上記に対して下記のように0のチェックを追加するのは入力値の不備への対策としては有効だけれど、真偽判定の本質とは無関係なものが混じっている気がする。  

トランジスタも「電圧がかかったら」で動作している。常に入力を監視しているのとは違う。  
```JavaScript:not
function not(a) {
    if (a === 1) {
        return 0;
    } else if (a === 0) {
        return 1;
    } else {
        return;
    }
}
```
二進数で扱う1と0と、論理回路で使う1と0とがそれぞれ直接対になっていることがややこしくしてるのかな。  
## ゆるコンピュータ科学ラジオ
> https://www.youtube.com/watch?v=cfn0xkIFceY&t=1303s  

きっかけはポットキャストのゆるコンピュータ科学ラジオ。どのようにして半導体の組み合わせで四則演算ができるのかを説明している回。基本となる加算の仕組みを図解付きのYouTubeで視聴した。  

そこで解説されていた論理記号の動作の一つ一つを、JavaScriptの関数として定義していった。  
それら小さな定義が組み合わさったり入れ子になったりして、一つの大きな仕組みができているのだとよくわかった。
## 壮大な無駄づかい
ふたつの値を取り扱うだけのトランジスタが膨大な数集まってCPUを形成し、OSやらいろいろな技術のうえやっとJavaScriptが動作している。
そんな高級言語で自分自身の根幹を成す原始的な1ビットをシミュレーションするという、一周まわったテクノロジーの壮大な無駄づかい。